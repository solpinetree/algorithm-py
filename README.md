## Array
- `continuous`
	- 아무리 긴 배열이라도 한 번의 연산으로 원하는 데이터에 바로 접근할 수 있음. **O(1)의 시간복잡도**를 가짐.
- 4 bytes each

## Linked List
- `discontinous`
	- **O(n)의 시간복잡도**
- 중간에 데이터를 추가/삭제할 때 용이함
- 8 bytes each [ key + value = node ]

## 제한 조건 보는 법

> 시간복잡도(`Big-O`) 에 데이터의 크기(`n`)을 넣어서 나온 값이 **10^8 이 넘으면** 시간 제한을 초과할 가능성이 있음

> 즉, 제한 조건으로 내가 선택할 수 있는 알고리즘이 뭔지 확인할 수 있다.
- [1 <= n <= 10^5], [1 <= n <= 10^4]

	-> nlogn, n, logn, 1 으로 풀으라는 뜻
- [1 <= n <= 10^3]

	-> n^2 로 풀어도 됨
	

## 접근 방법

1.  직관적으로 생각하기
	- 보통 완전 탐색으로 시작
	- 문제 상황을 단순화하여 생각하기
	- 문제 상황을 극한화하여 생각하기
2. 자료구조와 알고리즘 활용
	- `문제이해` 에서 파악한 내용을 토대로 어떤 자료구조를 사용하는 게 가장 적합한지 결정
	- 대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
	- 자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용
